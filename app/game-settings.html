<!DOCTYPE html>
<html lang="en" data-theme="light">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Game Settings</title>
        <link rel="stylesheet" href="main.css" />
    </head>
    <body>
        <h2 id="pageTitle">Game Settings</h2>

        <div class="form-item">
            <label for="gameTitle">Game Title:</label>
            <input type="text" id="gameTitle" placeholder="Enter game title" />
        </div>

        <div class="form-item">
            <label for="exePath">Executable:</label>
            <div class="selector">
                <input type="text" id="exePath" placeholder="Select game executable" />
                <button id="selectExe" class="secondary-button">Select Executable</button>
            </div>
        </div>

        <div class="form-item">
            <label for="iconPath">Icon (optional):</label>
            <div class="selector">
                <input type="text" id="iconPath" placeholder="Select game icon" />
                <button id="selectIcon" class="secondary-button">Select Icon</button>
            </div>
        </div>

        <div class="form-item">
            <label for="gameEngine">Game Engine:</label>
            <select id="gameEngine">
                <option value="">Select a game engine</option>
            </select>
        </div>

        <div id="options" style="display: none; margin-top: 1em">
            <h3>Engine Options</h3>
            <div id="engineOptions"></div>
        </div>

        <div class="footer">
            <button id="cancelButton" class="secondary-button">Cancel</button>
            <button id="saveGame" class="primary-button">Save</button>
        </div>

        <script>
            const fs = require("fs");
            const path = require("path");
            const os = require("os");
            const { openFile } = require("macos-open-file-dialog");

            // Paths
            const settingsPath = path.join(
                os.homedir(),
                "Library",
                "Application Support",
                "Xenolauncher",
                "global-settings.json"
            );
            const gamesPath = path.join(os.homedir(), "Library", "Application Support", "Xenolauncher", "games.json");
            const modulesDir = path.join(os.homedir(), "Library", "Application Support", "Xenolauncher", "modules");

            const moduleManifests = {};

            const __DEBUG_AUTODETECT = true;
            const dbg = (...args) => {
                if (__DEBUG_AUTODETECT) console.log("[AutoDetect]", ...args);
            };

            // ---------- Loaders ----------
            function loadSettings() {
                if (!fs.existsSync(settingsPath)) return { darkTheme: false };
                try {
                    return JSON.parse(fs.readFileSync(settingsPath, "utf8"));
                } catch {
                    return { darkTheme: false };
                }
            }
            function loadGames() {
                if (!fs.existsSync(gamesPath)) return {};
                try {
                    return JSON.parse(fs.readFileSync(gamesPath, "utf8"));
                } catch {
                    return {};
                }
            }
            function saveGames(games) {
                fs.writeFileSync(gamesPath, JSON.stringify(games, null, 2), "utf8");
            }

            // Apply theme early
            const settings = loadSettings();
            document.documentElement.setAttribute("data-theme", settings.darkTheme ? "dark" : "light");

            // ---------- Module manifests ----------
            function loadModuleManifests() {
                if (!fs.existsSync(modulesDir)) return;
                fs.readdirSync(modulesDir, { withFileTypes: true })
                    .filter((d) => d.isDirectory())
                    .forEach((d) => {
                        const mf = path.join(modulesDir, d.name, "manifest.json");
                        if (!fs.existsSync(mf)) return;
                        try {
                            moduleManifests[d.name] = JSON.parse(fs.readFileSync(mf, "utf8"));
                        } catch (e) {
                            console.error("Bad manifest in", d.name, e);
                        }
                    });
            }
            function populateEngineDropdown() {
                const sel = document.getElementById("gameEngine");
                Object.entries(moduleManifests).forEach(([key, m]) => {
                    const opt = document.createElement("option");
                    opt.value = key;
                    opt.textContent = m.name || key;
                    sel.appendChild(opt);
                });
            }

            // ---------- Options UI ----------
            function buildOptionsUI() {
                const engine = document.getElementById("gameEngine").value;
                dbg("buildOptionsUI", { engine });
                const optsDiv = document.getElementById("options");
                const container = document.getElementById("engineOptions");
                container.innerHTML = "";

                if (!engine || !moduleManifests[engine]) {
                    optsDiv.style.display = "none";
                    return;
                }

                const defs = moduleManifests[engine].gameArgs || {};
                Object.entries(defs).forEach(([key, def]) => {
                    const id = `arg-${key}`;
                    const wrapper = document.createElement("div");
                    wrapper.classList.add(def.type === "boolean" ? "form-toggle" : "form-item");

                    const label = document.createElement("label");
                    label.setAttribute("for", id);
                    label.textContent = def.label;
                    wrapper.appendChild(label);

                    let input;
                    if (def.type === "boolean") {
                        input = document.createElement("input");
                        input.type = "checkbox";
                        input.id = id;
                        input.checked = !!def.default;
                    } else {
                        input = document.createElement("input");
                        input.id = id;
                        input.name = key;
                        if (def.type === "int") {
                            input.type = "number";
                            input.step = "1";
                            input.value = def.default != null ? def.default : "";
                        } else if (def.type === "float") {
                            input.type = "number";
                            input.step = "any";
                            input.value = def.default != null ? def.default : "";
                        } else {
                            // string/other
                            input.type = "text";
                            input.value = def.default || "";
                        }
                    }

                    wrapper.appendChild(input);
                    container.appendChild(wrapper);
                });

                optsDiv.style.display = Object.keys(defs).length ? "block" : "none";
            }

            // ---------- Autodetect helpers ----------
            function normalizeExt(ext) {
                if (!ext) return "";
                return String(ext).replace(/^\.+/, "").toLowerCase();
            }
            function getPathExtLower(p) {
                if (!p) return "";
                let pp = p.trim();
                // remove trailing slash for bundles like .app/
                pp = pp.replace(/[\\/]+$/, "");
                const base = path.basename(pp);
                const idx = base.lastIndexOf(".");
                return idx >= 0 ? base.slice(idx + 1).toLowerCase() : "";
            }
            function isAppBundlePath(p) {
                return normalizeExt(getPathExtLower(p)) === "app";
            }
            function gameDirForFiles(exe) {
                // If it's an .app bundle, look inside the bundle; otherwise, look beside the file
                if (isAppBundlePath(exe)) {
                    return exe.replace(/[\\/]+$/, "");
                }
                return path.dirname(exe);
            }

            function detectEngineForPath(exe) {
                if (!exe) return null;
                const extOnPath = normalizeExt(getPathExtLower(exe));
                const dir = gameDirForFiles(exe);

                dbg("detectEngineForPath", { exe, extOnPath, dir });

                let bestKey = null;
                let bestScore = 0;
                let bestTie = { fileMatches: -1, extMatch: false };
                const strongMatches = []; // all_required satisfied

                for (const [key, manifest] of Object.entries(moduleManifests)) {
                    const ad = manifest.autodetect;
                    dbg("checking module", key, "has autodetect?", !!ad);
                    if (!ad) continue; // optional

                    const extListRaw = Array.isArray(ad.extensions)
                        ? ad.extensions
                        : ad.extension
                        ? [ad.extension]
                        : []; // backward compat
                    const extList = extListRaw.map(normalizeExt).filter(Boolean);
                    const hasExtRule = extList.length > 0;
                    const extMatch = hasExtRule ? extList.includes(extOnPath) : false;

                    const files = Array.isArray(ad.files) ? ad.files : [];
                    let fileMatches = 0;
                    let fileTotal = files.length;
                    if (fileTotal > 0) {
                        for (const rel of files) {
                            const probe = path.join(dir, rel);
                            if (fs.existsSync(probe)) fileMatches++;
                        }
                    }
                    const allRequired = !!ad.all_required;

                    dbg("module facts", { key, extList, extMatch, files, fileMatches, allRequired });

                    // Evaluate
                    if (allRequired) {
                        const needExt = hasExtRule ? extMatch : true;
                        const needFiles = fileTotal > 0 ? fileMatches === fileTotal : true;
                        if (needExt && needFiles) {
                            strongMatches.push({ key, fileMatches, extMatch });
                        }
                        continue; // skip scoring path for all_required
                    }

                    // Score-based selection (weights: ext=1, files up to 1)
                    let score = 0;
                    if (hasExtRule && extMatch) score += 1;
                    if (fileTotal > 0) score += fileMatches / fileTotal; // [0..1]

                    dbg("score", { key, score, hasExtRule, extMatch, fileMatches, fileTotal });

                    if (score > bestScore) {
                        bestScore = score;
                        bestKey = key;
                        bestTie = { fileMatches, extMatch };
                        dbg("new best", { bestKey, bestScore });
                    } else if (score === bestScore && score > 0) {
                        // Tie-break: prefer more file matches, then ext match
                        const better =
                            fileMatches > bestTie.fileMatches ||
                            (fileMatches === bestTie.fileMatches && extMatch && !bestTie.extMatch);
                        if (better) {
                            bestKey = key;
                            bestTie = { fileMatches, extMatch };
                            dbg("new best", { bestKey, bestScore });
                        }
                    }
                }

                if (strongMatches.length === 1) {
                    dbg("all_required winner", strongMatches[0].key);
                    dbg("all_required tie, picked", strongMatches[0].key, strongMatches);
                    return strongMatches[0].key;
                }
                if (strongMatches.length > 1) {
                    // Choose the strongest by fileMatches, then extMatch
                    strongMatches.sort((a, b) => {
                        if (b.fileMatches !== a.fileMatches) return b.fileMatches - a.fileMatches;
                        if (a.extMatch !== b.extMatch) return (b.extMatch ? 1 : 0) - (a.extMatch ? 1 : 0);
                        return 0;
                    });
                    return strongMatches[0].key;
                }

                const finalKey = bestScore > 0 ? bestKey : null;
                dbg("fallback winner", { bestKey, bestScore, finalKey });
                return finalKey;
            }

            function autodetectEngine() {
                if (window.__editingMode) {
                    dbg("autodetect skipped: editing mode");
                    return;
                } // don't autodetect when editing
                const exe = document.getElementById("exePath").value.trim();
                dbg("autodetect: exe path", exe);
                if (!exe) return;
                const key = detectEngineForPath(exe);
                dbg("autodetect result", { key });
                if (!key) return;
                const sel = document.getElementById("gameEngine");
                // Only set if the option exists
                const opt = Array.from(sel.options).find((o) => o.value === key);
                if (opt) {
                    sel.value = key;
                    buildOptionsUI();
                }
            }

            // ---------- File pickers ----------
            document.getElementById("selectExe").addEventListener("click", async () => {
                const p = await openFile("Select a game executable");
                if (p) {
                    document.getElementById("exePath").value = p;
                    autodetectEngine();
                }
            });
            document.getElementById("selectIcon").addEventListener("click", async () => {
                const p = await openFile("Select a game icon", ["png", "jpg", "jpeg", "ico", "gif"]);
                if (p) document.getElementById("iconPath").value = p;
            });
            document.getElementById("gameEngine").addEventListener("change", buildOptionsUI);

            // ---------- Init dropdowns ----------
            loadModuleManifests();
            populateEngineDropdown();
            dbg("manifests loaded", Object.keys(moduleManifests));

            // ---------- Determine mode (add vs edit) ----------
            const urlParams = new URLSearchParams(window.location.search);
            const gameId = urlParams.get("gameId"); // if present -> edit
            const games = loadGames();
            const editing = !!(gameId && games[gameId]);
            // expose to autodetect function without needing to pass around
            window.__editingMode = editing;

            document.getElementById("pageTitle").textContent = editing ? "Edit Game" : "Add Game";

            if (editing) {
                const gameData = games[gameId];
                document.getElementById("gameTitle").value = gameData.gameTitle || "";
                document.getElementById("exePath").value = gameData.gamePath || "";
                document.getElementById("iconPath").value = gameData.iconPath || "";
                document.getElementById("gameEngine").value = gameData.gameEngine || "";
                buildOptionsUI();
                const defs = moduleManifests[gameData.gameEngine]?.gameArgs || {};
                Object.entries(defs).forEach(([key, def]) => {
                    const el = document.getElementById(`arg-${key}`);
                    if (!el) return;
                    const saved = gameData.gameArgs?.[key];
                    if (def.type === "boolean") el.checked = typeof saved === "boolean" ? saved : !!def.default;
                    else el.value = saved != null ? saved : def.default || "";
                });
            } else {
                // Add mode: wire up live autodetect as the user types/pastes the path
                const exeInput = document.getElementById("exePath");
                exeInput.addEventListener("input", () => autodetectEngine());
                exeInput.addEventListener("change", () => autodetectEngine());
            }

            // ---------- Save handler: upsert ----------
            document.getElementById("saveGame").addEventListener("click", () => {
                const title = document.getElementById("gameTitle").value.trim();
                const exe = document.getElementById("exePath").value.trim();
                const icon = document.getElementById("iconPath").value.trim();
                const engine = document.getElementById("gameEngine").value;
                if (!title || !exe || !engine) return alert("Please fill in all fields.");

                const defs = moduleManifests[engine]?.gameArgs || {};
                const settingsObj = {};
                Object.entries(defs).forEach(([key, def]) => {
                    const el = document.getElementById(`arg-${key}`);
                    if (!el) return;
                    if (def.type === "boolean") settingsObj[key] = el.checked;
                    else if (def.type === "int") settingsObj[key] = parseInt(el.value, 10) || 0;
                    else if (def.type === "float") settingsObj[key] = parseFloat(el.value) || 0.0;
                    else settingsObj[key] = el.value;
                });

                const newData = {
                    gameTitle: title,
                    gamePath: exe,
                    iconPath: icon,
                    gameEngine: engine,
                    gameArgs: settingsObj,
                };

                const gamesNow = loadGames();
                if (editing) {
                    gamesNow[gameId] = newData;
                    try {
                        saveGames(gamesNow);
                        alert("Game settings saved!");
                    } catch (e) {
                        console.error("Error saving game:", e);
                        alert("Failed to save game: " + e.message);
                    }
                } else {
                    const nextID =
                        Object.keys(gamesNow)
                            .map((n) => parseInt(n, 10))
                            .reduce((m, c) => Math.max(m, isNaN(c) ? 0 : c), 0) + 1;
                    gamesNow[nextID] = newData;
                    try {
                        saveGames(gamesNow);
                        alert("Game added!");
                    } catch (e) {
                        console.error("Error saving game:", e);
                        alert("Failed to save game: " + e.message);
                    }
                }
                nw.Window.get().close();
            });

            document.getElementById("cancelButton").addEventListener("click", () => nw.Window.get().close());
        </script>
    </body>
</html>
