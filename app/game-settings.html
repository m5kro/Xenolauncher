<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <script src="global-settings.js"></script>
        <script>
            // Decide theme before CSS is parsed to prevent flash
            (function () {
                const s = GlobalSettings.loadGlobalSettings();
                GlobalSettings.applyTheme(s.darkTheme);

                // Avoid scrollbar/status-bar flash
                const meta = document.createElement("meta");
                meta.name = "color-scheme";
                meta.content = s.darkTheme ? "dark light" : "light dark";
                document.head.appendChild(meta);
            })();
        </script>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Game Settings</title>
        <link rel="stylesheet" href="main.css" />
    </head>
    <body>
        <h2 id="pageTitle">Game Settings</h2>

        <div class="form-item">
            <label for="gameTitle">Game Title:</label>
            <input type="text" id="gameTitle" placeholder="Enter game title" />
        </div>

        <div class="form-item">
            <label for="exePath">Executable:</label>
            <div class="selector">
                <input type="text" id="exePath" placeholder="Select game executable" />
                <button id="selectExe" class="secondary-button">Select Executable</button>
            </div>
        </div>

        <div class="form-item">
            <label for="iconPath">Icon (optional):</label>
            <div class="selector">
                <input type="text" id="iconPath" placeholder="Select game icon" />
                <button id="selectIcon" class="secondary-button">Select Icon</button>
            </div>
        </div>

        <div class="form-item">
            <label for="gameEngine">Game Engine:</label>
            <select id="gameEngine">
                <option value="">Select a game engine</option>
            </select>
        </div>

        <div id="options" style="display: none; margin-top: 1em">
            <h3>Engine Options</h3>
            <div id="engineOptions"></div>
        </div>

        <div class="footer">
            <button id="cancelButton" class="secondary-button">Cancel</button>
            <button id="saveGame" class="primary-button">Save</button>
        </div>

        <!-- Shared scripts -->
        <script src="window-utils.js"></script>
        <script src="games.js"></script>
        <script src="module.js"></script>

        <!-- Page logic -->
        <script>
            const fs = require("fs");
            const path = require("path");
            const os = require("os");
            const { openFile } = require("macos-open-file-dialog");

            const gs = GlobalSettings.loadGlobalSettings();
            const allowRemoteAutodetect = gs.nonInstalledAutodetect !== false;

            // Local manifests (installed modules)
            let moduleManifests = Module.readLocalManifests();

            function populateEngineDropdown() {
                const sel = document.getElementById("gameEngine");
                Object.entries(moduleManifests).forEach(([key, m]) => {
                    const opt = document.createElement("option");
                    opt.value = key;
                    opt.textContent = m.name || key;
                    sel.appendChild(opt);
                });
            }

            function refreshManifestsAndDropdown() {
                moduleManifests = Module.readLocalManifests();
                const sel = document.getElementById("gameEngine");
                sel.innerHTML = "";
                const ph = document.createElement("option");
                ph.value = "";
                ph.textContent = "Select a game engine";
                sel.appendChild(ph);
                populateEngineDropdown();
            }

            function buildOptionsUI() {
                const engine = document.getElementById("gameEngine").value;
                const optsDiv = document.getElementById("options");
                const container = document.getElementById("engineOptions");
                container.innerHTML = "";

                if (!engine || !moduleManifests[engine]) {
                    optsDiv.style.display = "none";
                    return;
                }

                const defs = moduleManifests[engine].gameArgs || {};

                // Helpers for multi-version
                function modulesDir() {
                    return path.join(GlobalSettings.getAppSupportDir(), "modules");
                }

                function readInstalledFromFs(argKey) {
                    try {
                        const p = path.join(modulesDir(), engine, "deps", argKey);
                        if (!fs.existsSync(p)) return [];
                        return fs
                            .readdirSync(p, { withFileTypes: true })
                            .filter((d) => d.isDirectory())
                            .map((d) => d.name);
                    } catch (e) {
                        console.warn("readInstalledFromFs failed", e);
                        return [];
                    }
                }

                async function populateInstalledSelect(selectEl, def, argKey) {
                    let versions = readInstalledFromFs(argKey);

                    // Clear + populate the <select>
                    selectEl.innerHTML = "";
                    if (!versions.length) {
                        const opt = document.createElement("option");
                        opt.value = "";
                        opt.textContent = "No versions installed";
                        selectEl.appendChild(opt);
                        selectEl.disabled = true;
                        return; // nothing else to do
                    }

                    versions
                        .map((v) => String(v))
                        .sort((a, b) => b.localeCompare(a, undefined, { numeric: true, sensitivity: "base" }))
                        .forEach((v) => {
                            const opt = document.createElement("option");
                            opt.value = v;
                            opt.textContent = v;
                            selectEl.appendChild(opt);
                        });
                    selectEl.disabled = false;

                    // Pick saved or default value if available
                    try {
                        const params = new URLSearchParams(window.location.search);
                        const currentGameId = params.get("gameId");
                        const allGames = (Games.loadGames && Games.loadGames()) || {};
                        const saved =
                            window.__editingMode &&
                            currentGameId &&
                            allGames[currentGameId] &&
                            allGames[currentGameId].gameArgs
                                ? allGames[currentGameId].gameArgs[argKey]
                                : null;

                        const desired = saved != null ? String(saved) : def.default != null ? String(def.default) : "";

                        if (desired) {
                            const match = Array.from(selectEl.options).find((o) => o.value === desired);
                            if (match) selectEl.value = desired;
                        }
                    } catch (e) {
                        console.warn("Failed to select saved/default version:", e);
                    }
                }

                Object.entries(defs).forEach(([key, def]) => {
                    const id = `arg-${key}`;
                    const wrapper = document.createElement("div");
                    wrapper.classList.add(def.type === "boolean" ? "form-toggle" : "form-item");

                    const label = document.createElement("label");
                    label.setAttribute("for", id);
                    label.textContent = def.label;
                    wrapper.appendChild(label);

                    let input;

                    if (def.type === "boolean") {
                        input = document.createElement("input");
                        input.type = "checkbox";
                        input.id = id;
                        input.checked = !!def.default;
                        wrapper.appendChild(input);
                        container.appendChild(wrapper);
                        return;
                    }

                    if (def.type === "multi-version") {
                        // selector + button row
                        const row = document.createElement("div");
                        row.className = "selector";

                        const select = document.createElement("select");
                        select.id = id;
                        select.name = key;
                        row.appendChild(select);

                        const btn = document.createElement("button");
                        btn.className = "secondary-button";
                        btn.textContent = "Versions";
                        btn.addEventListener("click", () => {
                            const url = new URL("version-manager.html", window.location.href);
                            url.searchParams.set("engine", engine);
                            url.searchParams.set("argKey", key);
                            url.searchParams.set("label", def.label || key);
                            if (def["version-script"]) url.searchParams.set("script", def["version-script"]);
                            openSubwindow(url.pathname + "?" + url.searchParams.toString(), null, async () => {
                                // Refresh installed list after closing
                                await populateInstalledSelect(select, def, key);
                            });
                        });
                        row.appendChild(btn);

                        wrapper.appendChild(row);
                        container.appendChild(wrapper);

                        // Fill the dropdown with installed versions
                        populateInstalledSelect(select, def, key);
                        return;
                    }

                    if (def.type === "dropdown") {
                        // <select> with options: [{ label: string, value: string }, ...]
                        const select = document.createElement("select");
                        select.id = id;
                        select.name = key;

                        const opts = Array.isArray(def.options) ? def.options : [];
                        if (!opts.length) {
                            const opt = document.createElement("option");
                            opt.value = "";
                            opt.textContent = "No options available";
                            select.appendChild(opt);
                            select.disabled = true;
                        } else {
                            opts.forEach((item) => {
                                if (!item) return;

                                // Allow "" but skip null/undefined
                                const rawValue = item.value;
                                if (rawValue === undefined || rawValue === null) return;

                                const value = String(rawValue); // can be ""
                                const labelTxt =
                                    item.label !== undefined && item.label !== null
                                        ? String(item.label)
                                        : String(rawValue); // fallback

                                const opt = document.createElement("option");
                                opt.value = value;
                                opt.textContent = labelTxt;
                                select.appendChild(opt);
                            });

                            // Preselect manifest default if present
                            if (def.default != null) {
                                const desired = String(def.default);
                                const match = Array.from(select.options).find((o) => o.value === desired);
                                if (match) select.value = desired;
                            } else if (select.options.length) {
                                select.selectedIndex = 0; // ensure something is selected when not editing
                            }
                        }

                        wrapper.appendChild(select);
                        container.appendChild(wrapper);
                        return;
                    }

                    if (def.type === "array") {
                        const containerDiv = document.createElement("div");
                        containerDiv.id = `${id}-container`;
                        containerDiv.className = "array-container";

                        // Associate label with the container for accessibility
                        label.setAttribute("for", `${id}-container`);

                        const list = document.createElement("div");
                        list.className = "array-list";
                        containerDiv.appendChild(list);

                        const addBtn = document.createElement("button");
                        addBtn.type = "button";
                        addBtn.className = "secondary-button add-array-btn";
                        addBtn.textContent = "Add value";
                        containerDiv.appendChild(addBtn);

                        function addArrayRow(val = "") {
                            const row = document.createElement("div");
                            row.className = "selector array-row";

                            const txt = document.createElement("input");
                            txt.type = "text";
                            txt.value = String(val ?? "");
                            row.appendChild(txt);

                            const rm = document.createElement("button");
                            rm.type = "button";
                            rm.className = "secondary-button remove-array-item";
                            rm.title = "Remove";
                            rm.textContent = "âˆ’";
                            rm.addEventListener("click", () => row.remove());
                            row.appendChild(rm);

                            list.appendChild(row);
                        }

                        let initialVals = [];
                        try {
                            const params = new URLSearchParams(window.location.search);
                            const currentGameId = params.get("gameId");
                            const allGames = (Games.loadGames && Games.loadGames()) || {};
                            const saved =
                                window.__editingMode &&
                                currentGameId &&
                                allGames[currentGameId] &&
                                allGames[currentGameId].gameArgs
                                    ? allGames[currentGameId].gameArgs[key]
                                    : null;
                            if (Array.isArray(saved)) initialVals = saved.map((v) => String(v));
                            else if (Array.isArray(def.default)) initialVals = def.default.map((v) => String(v));
                        } catch (e) {
                            console.warn("array: couldn't retrieve saved/default values", e);
                        }
                        if (!initialVals.length) initialVals = [""];
                        initialVals.forEach((v) => addArrayRow(v));

                        addBtn.addEventListener("click", () => addArrayRow(""));

                        wrapper.appendChild(containerDiv);
                        container.appendChild(wrapper);
                        return;
                    }

                    // default numeric/text handling for other types
                    input = document.createElement("input");
                    input.id = id;
                    input.name = key;
                    if (def.type === "int") {
                        input.type = "number";
                        input.step = "1";
                        input.value = def.default != null ? def.default : "";
                    } else if (def.type === "float") {
                        input.type = "number";
                        input.step = "any";
                        input.value = def.default != null ? def.default : "";
                    } else {
                        input.type = "text";
                        input.value = def.default || "";
                    }
                    wrapper.appendChild(input);
                    container.appendChild(wrapper);
                });

                optsDiv.style.display = Object.keys(defs).length ? "block" : "none";
            }

            // ---------- Remote autodetect (non-installed modules) ----------
            const autoDetectJsonPath = path.join(GlobalSettings.getAppSupportDir(), "autodetect.json");
            let remoteAutodetectMap = {};
            let remoteSyncDone = false;

            function ensureAppSupportDir() {
                try {
                    fs.mkdirSync(GlobalSettings.getAppSupportDir(), { recursive: true });
                } catch {}
            }
            function saveAutodetectJson(map) {
                try {
                    ensureAppSupportDir();
                    fs.writeFileSync(autoDetectJsonPath, JSON.stringify(map, null, 2), "utf8");
                } catch (e) {
                    console.error("Failed to write autodetect.json", e);
                }
            }
            function loadAutodetectJson() {
                try {
                    if (!fs.existsSync(autoDetectJsonPath)) return;
                    remoteAutodetectMap = JSON.parse(fs.readFileSync(autoDetectJsonPath, "utf8")) || {};
                } catch (e) {
                    console.warn("Failed to read autodetect.json", e);
                }
            }

            async function startAutodetectSyncWithTimeout() {
                if (!allowRemoteAutodetect || remoteSyncDone) return;
                const timeoutMs = 5000;
                const timer = new Promise((_, reject) => setTimeout(() => reject(new Error("timeout")), timeoutMs));
                try {
                    const map = await Promise.race([Module.fetchModulesForAutodetect(), timer]);
                    remoteAutodetectMap = map;
                    saveAutodetectJson(map);
                    remoteSyncDone = true;

                    const exe = (document.getElementById("exePath")?.value || "").trim();
                    const sel = document.getElementById("gameEngine");
                    if (!window.__editingMode && exe && sel && !sel.value) {
                        await tryRemoteAutodetect(exe);
                    }
                } catch (e) {
                    console.log("autodetect sync failed or timed out", e && e.message ? e.message : e);
                }
            }

            async function tryRemoteAutodetect(exe) {
                if (!exe) return null;
                if (!remoteAutodetectMap || !Object.keys(remoteAutodetectMap).length) return null;
                const remoteKey = Module.detectEngineFromAutodetectMap(exe, remoteAutodetectMap);
                if (remoteKey) {
                    const sel = document.getElementById("gameEngine");
                    if (sel) sel.value = "";
                    buildOptionsUI();

                    window.__pendingModuleInstallKey = remoteKey;
                    const shouldOpen = await AppDialog.confirm(
                        `Module "${remoteKey}" was autodetected but is not installed.\n\nOpen Module Manager to install it now?`,
                        "Engine Not Installed"
                    );
                    if (shouldOpen) {
                        const searchParam = encodeURIComponent(`${remoteKey}`);
                        openSubwindow(`module-manager.html?search=${searchParam}`, null, () => {
                            // After closing, refresh local manifests and reselect if installed
                            refreshManifestsAndDropdown();
                            if (moduleManifests[remoteKey]) {
                                document.getElementById("gameEngine").value = remoteKey;
                                buildOptionsUI();
                            }
                        });
                    }
                    return remoteKey;
                }
                return null;
            }

            function autodetectEngine() {
                if (window.__editingMode) return; // skip while editing
                const exe = document.getElementById("exePath").value.trim();
                if (!exe) return;

                const installedKey = Module.detectEngineForPath(exe, moduleManifests);
                if (installedKey) {
                    const sel = document.getElementById("gameEngine");
                    const opt = Array.from(sel.options).find((o) => o.value === installedKey);
                    if (opt) {
                        sel.value = installedKey;
                        buildOptionsUI();
                    }
                } else if (allowRemoteAutodetect) {
                    void tryRemoteAutodetect(exe);
                }
            }

            // ---------- File pickers ----------
            document.getElementById("selectExe").addEventListener("click", async () => {
                const p = await openFile("Select a game executable");
                if (p) {
                    document.getElementById("exePath").value = p;
                    autodetectEngine();
                }
            });
            document.getElementById("selectIcon").addEventListener("click", async () => {
                const p = await openFile("Select a game icon", ["png", "jpg", "jpeg", "ico", "gif"]);
                if (p) document.getElementById("iconPath").value = p;
            });
            document.getElementById("gameEngine").addEventListener("change", buildOptionsUI);

            // ---------- Init dropdowns ----------
            populateEngineDropdown();
            if (allowRemoteAutodetect) {
                loadAutodetectJson();
                startAutodetectSyncWithTimeout();
            }

            // ---------- Determine mode (add vs edit) ----------
            const urlParams = new URLSearchParams(window.location.search);
            const gameId = urlParams.get("gameId");
            const games = Games.loadGames();
            const editing = !!(gameId && games[gameId]);
            window.__editingMode = editing;

            document.getElementById("pageTitle").textContent = editing ? "Edit Game" : "Add Game";

            if (editing) {
                const gameData = games[gameId];
                document.getElementById("gameTitle").value = gameData.gameTitle || "";
                document.getElementById("exePath").value = gameData.gamePath || "";
                document.getElementById("iconPath").value = gameData.iconPath || "";
                document.getElementById("gameEngine").value = gameData.gameEngine || "";
                buildOptionsUI();
                const defs = moduleManifests[gameData.gameEngine]?.gameArgs || {};
                Object.entries(defs).forEach(([key, def]) => {
                    const el = document.getElementById(`arg-${key}`);
                    if (!el) return;
                    const saved = gameData.gameArgs?.[key];
                    if (def.type === "boolean") el.checked = typeof saved === "boolean" ? saved : !!def.default;
                    else el.value = saved != null ? saved : def.default || "";
                });
            } else {
                const exeInput = document.getElementById("exePath");
                exeInput.addEventListener("input", () => autodetectEngine());
                exeInput.addEventListener("change", () => autodetectEngine());
            }

            // ---------- Save handler ----------
            document.getElementById("saveGame").addEventListener("click", async () => {
                const title = document.getElementById("gameTitle").value.trim();
                const exe = document.getElementById("exePath").value.trim();
                const icon = document.getElementById("iconPath").value.trim();
                const engine = document.getElementById("gameEngine").value;
                if (!title || !exe || !engine) {
                    await AppDialog.alert("Please fill in all required fields.", "Missing Information");
                    return;
                }

                const defs = moduleManifests[engine]?.gameArgs || {};
                const settingsObj = {};
                Object.entries(defs).forEach(([key, def]) => {
                    // Special handling for array type
                    if (def.type === "array") {
                        const containerEl = document.getElementById(`arg-${key}-container`);
                        settingsObj[key] = []; // default
                        if (!containerEl) return;

                        const inputs = Array.from(containerEl.querySelectorAll('.array-row input[type="text"]'));
                        const values = inputs
                            .map((i) => String(i.value).trim()) // normalize
                            .filter((v) => v !== ""); // remove empty

                        settingsObj[key] = values;
                        return;
                    }

                    const el = document.getElementById(`arg-${key}`);
                    if (!el) return;
                    if (def.type === "boolean") settingsObj[key] = el.checked;
                    else if (def.type === "int") settingsObj[key] = parseInt(el.value, 10) || 0;
                    else if (def.type === "float") settingsObj[key] = parseFloat(el.value) || 0.0;
                    else settingsObj[key] = el.value;
                });

                const newData = {
                    gameTitle: title,
                    gamePath: exe,
                    iconPath: icon,
                    gameEngine: engine,
                    gameArgs: settingsObj,
                };

                const gamesNow = Games.loadGames();
                if (editing) {
                    gamesNow[gameId] = newData;
                    try {
                        Games.saveGames(gamesNow);
                        await AppDialog.alert("Game settings saved.", "Saved");
                    } catch (e) {
                        console.error("Error saving game:", e);
                        await AppDialog.alert("Failed to save game: " + e.message, "Save Failed");
                    }
                } else {
                    const nextID =
                        Object.keys(gamesNow)
                            .map((n) => parseInt(n, 10))
                            .reduce((m, c) => Math.max(m, isNaN(c) ? 0 : c), 0) + 1;
                    gamesNow[nextID] = newData;
                    try {
                        Games.saveGames(gamesNow);
                        await AppDialog.alert("Game added.", "Saved");
                    } catch (e) {
                        console.error("Error saving game:", e);
                        await AppDialog.alert("Failed to save game: " + e.message, "Save Failed");
                    }
                }
                nw.Window.get().close();
            });

            document.getElementById("cancelButton").addEventListener("click", () => nw.Window.get().close());
        </script>
    </body>
</html>
