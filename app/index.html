<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <script src="global-settings.js"></script>
        <script>
            // Decide theme before CSS is parsed to prevent flash
            (function () {
                const s = GlobalSettings.loadGlobalSettings();
                GlobalSettings.applyTheme(s.darkTheme);

                // Avoid scrollbar/status-bar flash
                const meta = document.createElement("meta");
                meta.name = "color-scheme";
                meta.content = s.darkTheme ? "dark light" : "light dark";
                document.head.appendChild(meta);
            })();
        </script>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Xenolauncher</title>
        <link rel="stylesheet" href="main.css" />
    </head>

    <body>
        <main class="content">
            <div class="header">
                <div class="search-wrap">
                    <input
                        id="searchInput"
                        class="search-input"
                        type="text"
                        placeholder="Search games…"
                        aria-label="Search games"
                        autocomplete="off"
                    />
                </div>
                <h1>No Games Found!</h1>
            </div>
            <div id="gamesGrid" class="games-grid"></div>
        </main>

        <div class="footer">
            <button id="addGameButton" class="primary-button">Add Game</button>
            <button id="moduleManagerButton" class="primary-button">Game Engines</button>
            <button id="globalSettingsButton" class="primary-button">Global Settings</button>
        </div>

        <!-- Shared scripts -->
        <script src="window-utils.js"></script>
        <script src="games.js"></script>
        <script src="module.js"></script>

        <!-- Page logic -->
        <script>
            let allGames = {};
            let currentQuery = "";
            const currentVersion = "0.4.0";

            // Compare "x.y.z" version strings. Returns true if remote > local.
            function hasUpdate(local, remote) {
                const l = (local || "0.0.0").split(".").map((n) => parseInt(n, 10) || 0);
                const r = (remote || "0.0.0").split(".").map((n) => parseInt(n, 10) || 0);
                for (let i = 0; i < 3; i++) {
                    if (r[i] > l[i]) return true;
                    if (r[i] < l[i]) return false;
                }
                return false;
            }

            async function checkLatestReleaseAndPrompt() {
                try {
                    const settings = GlobalSettings.loadGlobalSettings();
                    if (!settings.checkUpdatesOnStartup) return;

                    // Doesn't show pre-releases
                    const res = await fetch("https://api.github.com/repos/m5kro/Xenolauncher/releases/latest", {
                        headers: { Accept: "application/vnd.github+json" },
                    });
                    if (!res.ok) return;

                    const data = await res.json();
                    let latest = (data.tag_name || "").trim();
                    if (latest.startsWith("v")) latest = latest.slice(1); // just in case I accidentally tag with 'v'

                    // Expect "0.0.0" format; ignore unexpected tags silently
                    if (!/^\d+\.\d+\.\d+$/.test(latest)) return;

                    if (hasUpdate(currentVersion, latest)) {
                        const wants = confirm(
                            `A new Xenolauncher version (${latest}) is available (you have ${currentVersion}). ` +
                                `Would you like to update now?`
                        );
                        if (wants) {
                            const nodeRequire =
                                typeof window !== "undefined" && window.require ? window.require : require;
                            const { execSync } = nodeRequire("child_process");
                            // open the releases page in default browser
                            execSync("open https://github.com/m5kro/Xenolauncher/releases/latest");
                        }
                    }
                } catch (e) {
                    console.warn("App update check failed:", e);
                }
            }

            const bindDeleteButtons = () => {
                document.querySelectorAll(".delete-option").forEach((button) => {
                    button.removeEventListener("click", handleDeleteButtonClick);
                    button.addEventListener("click", handleDeleteButtonClick);
                });
            };

            const handleDeleteButtonClick = (event) => {
                const gameId = event.target.closest(".game-container").dataset.gameId;
                const settings = GlobalSettings.loadGlobalSettings();

                if (settings.deletionConfirmation) {
                    if (confirm("Are you sure you want to delete this game?")) {
                        const updated = Games.deleteGame(gameId);
                        alert("Game deleted!");
                        renderGamesGrid(updated);
                    }
                } else {
                    const updated = Games.deleteGame(gameId);
                    alert("Game deleted!");
                    renderGamesGrid(updated);
                }
            };

            document.addEventListener("DOMContentLoaded", () => bindDeleteButtons());

            const filterGames = (query) => {
                currentQuery = (query || "").trim().toLowerCase();
                if (!currentQuery) {
                    renderGamesGrid(allGames);
                    return;
                }
                const filtered = {};
                for (const [id, game] of Object.entries(allGames)) {
                    const title = (game.gameTitle || "").toLowerCase();
                    if (title.includes(currentQuery)) filtered[id] = game;
                }
                renderGamesGrid(filtered);
            };

            const renderGamesGrid = (games) => {
                const gamesGrid = document.getElementById("gamesGrid");
                const header = document.querySelector(".content h1");
                const isListView = !!GlobalSettings.loadGlobalSettings().listView;

                // Toggle container class
                gamesGrid.classList.remove("games-grid", "games-list");
                gamesGrid.classList.add(isListView ? "games-list" : "games-grid");

                gamesGrid.innerHTML = "";

                if (Object.keys(games).length === 0) {
                    header.style.display = "block";
                    return;
                } else {
                    header.style.display = "none";
                }

                // List view
                if (isListView) {
                    for (const [id, game] of Object.entries(games)) {
                        const row = document.createElement("div");
                        row.className = "game-row";
                        row.dataset.gameId = id;

                        // Left: icon or fallback letter
                        const left = document.createElement("div");
                        left.className = "row-left";
                        if (game.iconPath) {
                            const img = document.createElement("img");
                            img.src = `file://${game.iconPath}`;
                            img.alt = `${game.gameTitle || "Game"} icon`;
                            img.className = "row-icon";
                            left.appendChild(img);
                        } else {
                            const letter = document.createElement("div");
                            letter.className = "row-fallback";
                            letter.textContent = (game.gameTitle || "?").charAt(0).toUpperCase();
                            left.appendChild(letter);
                        }

                        // Middle: title
                        const main = document.createElement("div");
                        main.className = "row-main";
                        const title = document.createElement("div");
                        title.className = "row-title";
                        title.title = game.gameTitle || "";
                        title.textContent = game.gameTitle || "Untitled";
                        main.appendChild(title);

                        // Right: options-button only (no Play button)
                        const actions = document.createElement("div");
                        actions.className = "row-actions";

                        const optionsButton = document.createElement("button");
                        optionsButton.className = "options-button row-options-button";
                        optionsButton.setAttribute("aria-label", "More options");
                        optionsButton.textContent = "⋮";

                        const optionsMenu = document.createElement("div");
                        optionsMenu.className = "options-menu";
                        optionsMenu.innerHTML = `
        <button class="settings-option">Settings</button>
        <button class="delete-option">Delete</button>
      `;

                        actions.appendChild(optionsButton);
                        actions.appendChild(optionsMenu);

                        row.appendChild(left);
                        row.appendChild(main);
                        row.appendChild(actions);
                        gamesGrid.appendChild(row);

                        const launch = () => Module.launchWithEngine(game, { openSubwindow });

                        // Launch when the row (anywhere) is clicked, except on menu/options-button
                        row.addEventListener("click", (e) => {
                            if (e.target.closest(".row-options-button") || e.target.closest(".options-menu")) return;
                            launch();
                        });

                        optionsButton.addEventListener("click", (e) => {
                            e.stopPropagation();
                            optionsMenu.classList.toggle("show");
                        });

                        optionsMenu.querySelector(".settings-option").addEventListener("click", (e) => {
                            e.stopPropagation();
                            openSubwindow("game-settings.html", row.dataset.gameId);
                        });

                        // let bindDeleteButtons hook the handler, but don't trigger row launch
                        optionsMenu.querySelector(".delete-option").addEventListener("click", (e) => {
                            e.stopPropagation();
                        });

                        // close menu on outside click
                        document.addEventListener("click", (event) => {
                            if (!optionsMenu.contains(event.target) && !optionsButton.contains(event.target)) {
                                optionsMenu.classList.remove("show");
                            }
                        });
                    }
                    bindDeleteButtons();
                    return;
                }

                // Grid view
                for (const [id, game] of Object.entries(games)) {
                    const gameContainer = document.createElement("div");
                    gameContainer.className = "game-container";
                    gameContainer.dataset.gameId = id;

                    const gameBox = document.createElement("div");
                    gameBox.className = "game-box";

                    if (game.iconPath) {
                        const gameIcon = document.createElement("img");
                        gameIcon.src = `file://${game.iconPath}`;
                        gameIcon.classList.add("game-icon");
                        gameBox.appendChild(gameIcon);
                    } else {
                        gameBox.textContent = (game.gameTitle || "?").charAt(0).toUpperCase();
                    }

                    const titleContainer = document.createElement("div");
                    titleContainer.className = "title-container";

                    const title = document.createElement("div");
                    title.className = "game-title";
                    title.textContent = formatTitle(game.gameTitle || "Untitled");

                    const optionsButton = document.createElement("button");
                    optionsButton.className = "options-button";
                    optionsButton.textContent = "⋮";

                    const optionsMenu = document.createElement("div");
                    optionsMenu.className = "options-menu";
                    optionsMenu.innerHTML = `
        <button class="settings-option">Settings</button>
        <button class="delete-option">Delete</button>
      `;

                    titleContainer.appendChild(title);
                    titleContainer.appendChild(optionsButton);

                    gameContainer.appendChild(gameBox);
                    gameContainer.appendChild(titleContainer);
                    gameContainer.appendChild(optionsMenu);

                    gamesGrid.appendChild(gameContainer);

                    gameBox.addEventListener("click", () => {
                        Module.launchWithEngine(game, { openSubwindow });
                    });

                    optionsButton.addEventListener("click", () => {
                        optionsMenu.classList.toggle("show");
                    });

                    optionsMenu.querySelector(".settings-option").addEventListener("click", () => {
                        openSubwindow("game-settings.html", gameContainer.dataset.gameId);
                    });

                    document.addEventListener("click", (event) => {
                        if (!optionsMenu.contains(event.target) && !optionsButton.contains(event.target)) {
                            optionsMenu.classList.remove("show");
                        }
                    });
                }

                bindDeleteButtons();
            };

            // React to settings changed in subwindows
            window.onSettingsUpdated = (settings) => {
                // Re-render with the latest listView immediately, keeping the current search query
                filterGames(currentQuery);
            };

            const formatTitle = (title) => {
                if (title[9] === " ") title = title.substring(0, 9) + title.substring(10);
                if (title.length > 18) title = title.substring(0, 15) + "...";
                return title.match(/.{1,9}/g).join("\n");
            };

            // check for module updates and optionally open Module Manager (installed only)
            async function promptForModuleUpdatesIfAny() {
                try {
                    const settings = GlobalSettings.loadGlobalSettings();
                    if (!settings.checkModuleUpdatesOnStartup) return;

                    const installedSet = Module.getInstalledModuleFolders();
                    if (!installedSet || installedSet.size === 0) return;

                    const localManifests = Module.readLocalManifests();
                    const remote = await Module.fetchRemoteManifestsList();

                    // Full updates
                    const fullUpdates = remote.filter((r) => {
                        if (!installedSet.has(r.folder)) return false;
                        const localVer = localManifests[r.folder]?.version;
                        return Module.hasUpdate(localVer, r.version);
                    });

                    // Dependency-only updates
                    let depUpdateFolders = new Set();
                    try {
                        depUpdateFolders = await Module.checkDependencyUpdatesForFolders([...installedSet]);
                    } catch (e) {
                        console.warn("Dependency update scan failed:", e);
                    }

                    const needing = new Set(fullUpdates.map((m) => m.folder));
                    for (const f of depUpdateFolders) needing.add(f);

                    if (needing.size > 0) {
                        const wants = confirm(
                            `Updates are available for ${needing.size} module${needing.size > 1 ? "s" : ""}. ` +
                                `Would you like to open the Module Manager to install them now?`
                        );
                        if (wants) {
                            openSubwindow("module-manager.html?showInstalled=1");
                        }
                    }
                } catch (e) {
                    console.warn("Module update check failed:", e);
                }
            }

            // make init async so we can await the checks
            async function init() {
                const games = Games.loadGames();
                allGames = games;
                renderGamesGrid(games);

                const settings = GlobalSettings.loadGlobalSettings();

                GlobalSettings.ensureFirstSetup(openSubwindow);
                GlobalSettings.checkAndHandleUpdate(currentVersion, openSubwindow);

                document
                    .getElementById("addGameButton")
                    .addEventListener("click", () => openSubwindow("game-settings.html"));
                document
                    .getElementById("globalSettingsButton")
                    .addEventListener("click", () => openSubwindow("global-settings.html"));
                document.getElementById("moduleManagerButton").addEventListener("click", () => {
                    const showInstalled = false;
                    openSubwindow(`module-manager.html?showInstalled=${showInstalled ? "1" : "0"}`);
                });

                const searchInput = document.getElementById("searchInput");
                searchInput.addEventListener("input", (e) => filterGames(e.target.value));

                Games.watchGamesFile(() => {
                    allGames = Games.loadGames();
                    filterGames(currentQuery);
                });

                // 1) Check app release from GitHub
                await checkLatestReleaseAndPrompt();

                // 2) Then check module updates
                await promptForModuleUpdatesIfAny();
            }

            init();
        </script>
    </body>
</html>
